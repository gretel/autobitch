#!/usr/bin/env bash
#
# -*- mode: bash; coding:utf-8; tab-width: 4; indent-tabs-mode: nil; -*-
# https://github.com/gretel/automagic
# tom hensel <github@jitter.eu> 2016

# pyenv_virtualenv: call pyenv to change the python version (it's location)
layout_pyenv() {
    local py_ver="$1"
    check_string "$py_ver" || return 1
    if ! pyenv shell "$py_ver"; then
        log_error "⚠ calling 'pyenv shell $py_ver' failed!"; return 2
    fi
    export PYENV_VIRTUALENV_DISABLE_PROMPT=1
}

# pyenv_virtualenv: call pyenv to activate a virtualenv it manages
layout_pyenv_virtualenv() {
    local venv_id="$1"
    check_string "$venv_id" || return 1
    if ! pyenv activate "$venv_id"; then
        log_error "⚠ calling 'pyenv activate $venv_id' failed!"; return 2
    fi
    export PYENV_VIRTUALENV_DISABLE_PROMPT=1
}

# pyenv_less: the layout pyenv supposes (~/.pyenv)
#   but don't actually require or call pyenv
layout_pyenv_less() {
    local python_ver="$1"
    check_string "$python_ver" || return 1
    export PYENV_VERSION="$python_ver"

    local pyenv_root="$HOME/.pyenv"
    check_path "$pyenv_root" || return 1
    export PYENV_ROOT="$pyenv_root"

    local python_shims="$HOME/.pyenv/shims"
    PATH_add "$python_shims"

    # local python_venv_shims="$HOME/.pyenv/plugins/pyenv-virtualenv/shims"
    # PATH_add "$python_venv_shims"

    local python_dir="$HOME/.pyenv/versions/$python_ver"
    check_path "$python_dir" || return 1

    export PYTHONPATH="$python_dir/lib/python3.5/site-packages"
    local python_bin_dir="$python_dir/bin"

    check_exec "$python_bin_dir/python" || return 1
    PATH_add "$python_bin_dir"

    path_add MANPATH "$python_dir/share/man"
}

# layout_virtualenv: name is bit ambigious - it's does not require virtualenv
# nor in particular the 'activate' script it puts into the virtualenv
# it is emulated here closely - should be very compatible
layout_virtualenv() {
    local venv_path="$1"
    check_string "$venv_path" || return 1
    unalias pydoc 2>/dev/null
    pydoc () {
        python -m pydoc "$@"
    }
    # cleanup
    unset PYTHONPATH
    unset PYENV_VERSION
    if test -z "${PYTHONHOME+_}"; then
        unset PYTHONHOME
    fi
    export VIRTUAL_ENV="$venv_path"
    PATH_add "$VIRTUAL_ENV/bin"

    # export PIP_REQUIRE_VIRTUALENV=1
    # TODO: pip caching dir?

    # if there is a pythonrc file use it
    local python_rc_file
    if python_rc_file="$HOME/.python/pythonrc.py"; then
        export PYTHONSTARTUP="$python_rc_file"
    fi
    # if there is no history file create it
    export PYTHON_HISTORY_FILE
    if ! PYTHON_HISTORY_FILE="$HOME/.python_history"; then
        touch "$PYTHON_HISTORY_FILE"
    fi
}

# layout_rubies: layout chruby supposes (~/.rubies, ~/.gem)
layout_rubies() {
    local ruby_ver="$1"
    check_string "$ruby_ver" || return 1

    local ruby_dir="$HOME/.rubies/ruby-$ruby_ver"
    check_string "$ruby_ver" && check_path "$ruby_dir" || return 1
    export RUBY_HOME="$ruby_dir"
    local ruby_dir_bin="$HOME/.rubies/ruby-$ruby_ver/bin"
    check_exec "$ruby_dir_bin/ruby" || return 1
    PATH_add "$ruby_dir_bin"

    local gem_dir="$HOME/.gem/ruby/$ruby_ver"
    check_path "$gem_dir"
    export GEM_HOME="$gem_dir" GEM_PATH="$gem_dir"
    local gem_dir_bin="$HOME/.rubies/ruby-$ruby_ver/bin"
    PATH_add "$gem_dir_bin"

    path_add MANPATH "$ruby_dir/share/man"
}


use_auto_ruby () {
    local rb_string
    local rb_ver
    local rb_which
    local rbver_file="$PWD/.ruby-version"
    if rb_ver=$(gather_file "$rbver_file"); then
        log_status "⚑ ruby ${rb_ver} required in {$(user_rel_path "$rbver_file")}"
        layout rubies "$rb_ver"
    fi
    if rb_which="$(which ruby)"; then
        # TODO: use version for comparison
        rb_string=( $(expect_usage "$rb_which -v" "ruby") )
        log_status "$(tput bold)✓$(tput sgr0) ruby ${rb_string[1]} at {$(user_rel_path "$rb_which")}"
    else
        log_error "⁈ expected ruby at '$rb_which' to be in PATH!"
    fi
}

use_auto_python () {
    local py_string
    local py_which
    local venv_id
    local pyver_file="$PWD/.python-version"
    local py_ver
    py_ver=$(gather_file "$pyver_file")
    local py_activate="$PWD/bin/activate"

    if py_ver=$(gather_file "$pyver_file"); then
        log_status "⚑ python ${py_ver} required in {$(user_rel_path "$pyver_file")}"
        layout pyenv_less "$py_ver"
        # TODO: check if venv and bin path match
    elif test -f "$py_activate"; then
        local venv_path="$PWD"
        log_status "⚑ python virtualenv at {$(user_rel_path "$venv_path")}"
        layout virtualenv "$venv_path"
    fi
    py_which="$(which python)"
    if test -x "$py_which"; then
        local py_string
        py_string=( $(expect_usage "$py_which -V" "Python $py_ver") ) || return 1
        log_status "$(tput bold)✓$(tput sgr0) python ${py_string[1]} at {$(user_rel_path "$py_which")}"
    else
        log_error "⁈ expected python at '$py_which' to be in PATH!"
    fi
}


check_string() {
    if test -z "$1"; then
        log_error "⧄ argument is expected to be passed."; return 1
    fi
}

check_path() {
    if ! test -d "$1"; then
        log_error "⧄ path '$1' is expected to exist."; return 1
    fi
}

check_exec() {
    if ! test -x "$1"; then
        log_error "⧄ file '$1' is expected to be executable."; return 1
    fi
}

gather_file() {
    test -f "$1" || return 1;
    OLDIFS="$IFS"
    IFS="${IFS}"$'\r'
    wrds=( $(cut -b 1-1024 "$1") )
    IFS="$OLDIFS"
    echo "${wrds[0]}"
}

expect_usage() {
    local bin="$1"
    local should="$2"
    local result
    result=$($bin 2>&1)
    case "$result" in
        *"$should"*)
            echo "$result"
            return 0
            ;;
        '')
            log_error "⧄ could not find executable in PATH!"
            return 1
            ;;
        *)
            log_error "⧄ expected output of '$bin' to match '$should' but got '$result'!"
            return 1
            ;;
    esac
}

get_abbrv_pwd() {
    cwd="$(user_rel_path "$1")"
    base="${cwd##*/}"
    dir="${cwd%/*}"
    echo "${dir##*/}/$base"
}

auto_log_prefix() {
    local cwd
    cwd="$(get_abbrv_pwd "$1")"
    export DIRENV_LOG_FORMAT
    DIRENV_LOG_FORMAT=" $(tput setaf 4)[$cwd]$(tput sgr0) $(tput setaf 7)%s$(tput sgr0)"
}

### end
